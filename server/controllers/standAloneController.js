const { curlRequest } = require('../utils/curlUtils');
const { pathTraversal } = require('../utils/vulnerabilitiesUtils/pathTraversalUtils');
const { 
    checkPassed, 
    getData 
} = require('../utils/vulnerabilitiesUtils/sqliUtils');
const getOutDated = require('../utils/techScannerUtils');
const { fetchRequest } = require('../utils/fetchUtils');
const sqliPayloads = require('../payloads/sqli')

const isItUp = async (url) => {
    const responseCode = (await curlRequest(url, { responseCode: true })).response;
    console.log('Response Code:', responseCode);
    if (responseCode !== '200' && responseCode !== '302') {
        return false;
    } else {
        return true;
    }
}

const checkHeaders = async (url) => {
    const headersData = (await fetchRequest(url, { getHeaders: true })).headers;

    const securityHeaders = [
        'X-Frame-Options',
        'Content-Security-Policy',
        'Strict-Transport-Security',
        'X-Content-Type-Options',
        'Referrer-Policy',
        'Feature-Policy'
    ];
    
    let missingHeaders = [];
    for (const header of securityHeaders) {
        if (!headersData.hasOwnProperty(header)) {
            missingHeaders.push(header);
        }
    }

    return missingHeaders;
}

const outDated = async (url) => {
    const outDatedComponents = await getOutDated(url);

    return outDatedComponents;
}

const pathTraversalCheck = async (url) => {
    const traversalResult = await pathTraversal(url);
    return traversalResult;
}

const checkSQLi = async (url) => {
    let vulnerability = {};
    let getVulnerability = [];
    let postVulnerability = [];

    try {
        const html = await fetchRequest(url);
        const payloads = sqliPayloads;
        const { queryParams, formDataNames } = await getData(html['data']);

        if (queryParams.length === 0) {
            console.log('No query parameters found. Skipping GET requests.');
        } else {
            for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                    for (const paramName of queryParams) {
                        const testUrl = `${url}?${paramName}=${encodeURIComponent(payloadValue)}`;
                        const requestOptions = { sendTime: true };
                        const response = await fetchRequest(testUrl, requestOptions);
                        if (response.responseTime && response.responseTime >= 5000) {
                            getVulnerability.push({ paramName, payloadType, payloadKey, payloadValue });
                            break;
                        }
                    }
                }
            }
        }

        if (formDataNames.length === 0) {
            console.log('No form data names found. Skipping POST requests.');
        } else {
            for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                    const formData = new URLSearchParams();
                    formDataNames.forEach((name) => {
                        formData.append(name, payloadValue);
                    });
                    const requestOptions = {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: formData.toString(),
                        sendTime: true,
                    };
                    const response = await fetchRequest(url, requestOptions);
                    if (response.responseTime && response.responseTime >= 5000) {
                        postVulnerability.push({ formDataNames, payloadType, payloadKey, payloadValue });
                        break;
                    }
                }
            }
        }

        vulnerability = { getVulnerability, postVulnerability };
    } catch (error) {
        console.error('Error:', error);
    }
    console.log(vulnerability);
    return vulnerability;
};

// Example usage:
const targetUrl = 'http://0.0.0.0:8080/login';
checkSQLi(targetUrl);

module.exports = {
    isItUp,
    checkHeaders,
    outDated,
    pathTraversalCheck,
    checkSQLi,
}