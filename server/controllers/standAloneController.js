const { curlRequest } = require('../utils/curlUtils');
const { pathTraversal } = require('../utils/vulnerabilitiesUtils/pathTraversalUtils');
const { 
    checkPassed, 
    getData,
    checkResponse,
    sendRequest,

} = require('../utils/vulnerabilitiesUtils/sqliUtils');
const getOutDated = require('../utils/techScannerUtils');
const { fetchRequest } = require('../utils/fetchUtils');
const { 
    sqlPayloads,
    timePayloads
} = require('../payloads/sqli');

const isItUp = async (url) => {
    const responseCode = (await curlRequest(url, { responseCode: true })).response;
    console.log('Response Code:', responseCode);
    if (responseCode !== '200' && responseCode !== '302') {
        return false;
    } else {
        return true;
    }
}

const checkHeaders = async (url) => {
    const headersData = (await fetchRequest(url, { getHeaders: true })).headers;

    const securityHeaders = [
        'X-Frame-Options',
        'Content-Security-Policy',
        'Strict-Transport-Security',
        'X-Content-Type-Options',
        'Referrer-PoSlicy',
        'Feature-Policy'
    ];
    
    let missingHeaders = [];
    for (const header of securityHeaders) {
        if (!headersData.hasOwnProperty(header)) {
            missingHeaders.push(header);
        }
    }

    return missingHeaders;
}

const outDated = async (url) => {
    const outDatedComponents = await getOutDated(url);

    return outDatedComponents;
}

const pathTraversalCheck = async (url) => {
    const traversalResult = await pathTraversal(url);
    return traversalResult;
}

const checkSQLi = async (url) => {
    try {
        const vulnerability = {
            GET: {},
            POST: [],
        };

        const html = await sendRequest(url, null, null, 'GET');
        const payloads = sqlPayloads;
        const { queryParams, formDataNames } = await getData(html['data']);
        const sameFunc = ['errorBased', 'stackedQueries'];
        let gotVuln = 0;
        let gotGet = false;

        // Do GET
        if (queryParams.length > 0) {
            for (const paramName of queryParams) {
                if (gotVuln > 5) {
                    break;
                }
                for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                    for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                        const testUrl = `${url}?${paramName}=${encodeURIComponent(payloadValue)}`;
                        const response = await sendRequest(testUrl, null, null, 'GET');
                        if (sameFunc.includes(payloadType)) {
                            if (checkResponse(response.data)) {
                                vulnerability.GET[paramName] = payloadValue;
                                gotVuln++;
                                if (gotVuln >= 2) {
                                    break;
                                }
                            }
                        } else if (payloadType === 'bypassBassed') {
                            if (checkPassed(response.data)) {
                                vulnerability.GET[paramName] = payloadValue;
                                gotVuln++;
                                if (gotVuln >= 2) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            console.log('No query parameters found. Skipping GET requests.');
        }

        // Do POST
        if (formDataNames.length > 0 && !gotGet) {
            for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                if (gotVuln > 5) {
                    break;
                }
                for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                    const formData = new URLSearchParams();
                    formDataNames.forEach((name) => {
                        formData.append(name, payloadValue);
                    });
                    const requestOptions = {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: formData.toString(),
                    };
                    const response = await sendRequest(url, formData.toString(), requestOptions.headers, requestOptions.method);
                    console.log("Payload:", payloadValue);
                    if (payloadType === 'bypassBassed') {
                        if (await checkPassed(response.data)) {
                            vulnerability.POST.push(payloadValue);
                            gotVuln++;
                            if (gotVuln >= 5) {
                                break;
                            }
                        }
                    } else if (sameFunc.includes(payloadType)) {
                        if (await checkResponse(response.data)) {
                            vulnerability.POST.push(payloadValue);
                            gotVuln++;
                            if (gotVuln >= 5) {
                                break;
                            }
                        }
                    }
                }
            }
        } else {
            console.log('No form data names found. Skipping POST requests.');
        }

        // Check time-based vulnerability if no other vulnerabilities found
        if (Object.keys(vulnerability.GET).length === 0 && vulnerability.POST.length === 0) {
            console.log("Found nothing moving to time based!");
            await checkTimeBasedVulnerability(url, queryParams, formDataNames);
        }

        console.log('Vulnerability:', vulnerability);
        return vulnerability;
    } catch (error) {
        console.error('Error:', error);
    }
};

const checkTimeBasedVulnerability = async (url, queryParams, formDataNames) => {
    const payloadsOfType = timePayloads;
        for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
            for (const paramName of queryParams) {
                const testUrl = `${url}?${paramName}=${encodeURIComponent(payloadValue)}`;
                const requestOptions = { sendTime: true };
                const response = await fetchRequest(testUrl, requestOptions);
                if (response.responseTime && response.responseTime >= 5000) {
                    console.log(`Time-Based SQL injection successful for ${payloadValue}`);
                    return;
                }
            }
        }

    for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
        const formData = new URLSearchParams();
        formDataNames.forEach((name) => {
            formData.append(name, payloadValue);
        });
        const requestOptions = {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: formData.toString(),
            sendTime: true,
            redirect: "follow"
        };
        const response = await fetchRequest(url, requestOptions);
        if (response.responseTime && response.responseTime >= 5000) {
            console.log(`Time-Based SQL injection successful for ${payloadValue}`);
            return;
        }
    }

    console.log('Time-Based SQL injection not detected on', url);
};

module.exports = {
    isItUp,
    checkHeaders,
    outDated,
    pathTraversalCheck,
    checkSQLi,
}