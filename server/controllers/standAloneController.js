const { curlRequest } = require('../utils/curlUtils');
const { pathTraversal } = require('../utils/vulnerabilitiesUtils/pathTraversalUtils');
const { 
    checkPassed, 
    getData,
    checkResponse,
    sendRequest,
} = require('../utils/vulnerabilitiesUtils/sqliUtils');
const getOutDated = require('../utils/techScannerUtils');
const { fetchRequest } = require('../utils/fetchUtils');
const { 
    sqlPayloads,
    timePayloads
} = require('../payloads/sqli');
const scrape = require('../utils/puppeteerUtils');

const isItUp = async () => {
    const urls = Object.keys(global.scrapedData);
    console.log("URLS:", urls);
    for (const url of urls) {
        try {
            if (global.scrapedData.hasOwnProperty(url)) {
                const responseCode = (await curlRequest(url, { responseCode: true })).response;
                console.log(`URL: ${url}, Response Code: ${responseCode}`);
                if (responseCode !== '200' && responseCode !== '302') {
                    return false;
                } else {
                    return true;
                }
            }
        } catch (error) {
            console.error(`Error checking URL ${url}:`, error);
            return false;
        }
    }
}

const checkHeaders = async () => {
    const missingHeaders = new Set();
    const urls = Object.keys(global.scrapedData);
    for (const url of urls) {
        const headersData = (await fetchRequest(url, { getHeaders: true })).headers;

        const securityHeaders = [
            'X-Frame-Options',
            'Content-Security-Policy',
            'Strict-Transport-Security',
            'X-Content-Type-Options',
            'Referrer-Policy',
            'Feature-Policy'
        ];
        
        for (const header of securityHeaders) {
            if (!headersData.hasOwnProperty(header)) {
                missingHeaders.add(header);
            }
        }

        console.log(`URL: ${url}, Missing Headers:`, Array.from(missingHeaders));
    }

    return Array.from(missingHeaders); 
}

const outDated = async () => {
    const urls = Object.keys(global.scrapedData);
    const outDatedComponents = await getOutDated(urls[0]);
    console.log(`URL: ${urls[0]}, Outdated Components:`, outDatedComponents);
    return outDatedComponents;
}

const pathTraversalCheck = async () => {
    const urls = Object.keys(global.scrapedData);
    const traversalResults = {};
    
    for (const url of urls) {
        const scrapedData = global.scrapedData[url];
        const traversalResult = await pathTraversal(url, scrapedData);
        traversalResults[url] = traversalResult;
        console.log(`URL: ${url}, Path Traversal Result:`, traversalResult);
    }

    return traversalResults;
};

const checkSQLi = async () => {
    const vulnerability = {
        GET: {},
        POST: {}, // Initialize POST as an object
    };
    const urls = Object.keys(global.scrapedData);
    for (const url of urls) {
        console.log(`Testing URL: ${url}`);
        try {
            const html = (await sendRequest(url, null, null, 'GET')).data;
            const payloads = sqlPayloads;
            const { queryParams, formDataNames } = await getData(html);
            const sameFunc = ['errorBased', 'stackedQueries'];
            let gotVuln = 0;
            let gotGet = false;

            // Do GET
            if (queryParams.length > 0) {
                for (const paramName of queryParams) {
                    if (gotVuln > 5) {
                        break;
                    }const checkSQLi = async () => {
                        const vulnerability = {
                            GET: {},
                            POST: {},
                        };
                        const urls = Object.keys(global.scrapedData);
                        for (const url of urls) {
                            console.log(`Testing URL: ${url}`);
                            try {
                    
                                const html = (await sendRequest(url, null, null, 'GET')).data;
                                const payloads = sqlPayloads;
                                const { queryParams, formDataNames } = await getData(html);
                                const sameFunc = ['errorBased', 'stackedQueries'];
                                let gotVuln = 0;
                                let gotGet = false;
                    
                                // Do GET
                                if (queryParams.length > 0) {
                                    for (const paramName of queryParams) {
                                        if (gotVuln > 5) {
                                            break;
                                        }
                                        for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                                            for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                                                const testUrl = `${url}?${paramName}=${encodeURIComponent(payloadValue)}`;
                                                const response = await sendRequest(testUrl, null, null, 'GET');
                                                if (sameFunc.includes(payloadType)) {
                                                    if (checkResponse(response.data)) {
                                                        vulnerability.GET[url] = {
                                                            paramName,
                                                            payloadValue
                                                        };
                                                        gotVuln++;
                                                        if (gotVuln >= 2) {
                                                            break;
                                                        }
                                                    }
                                                } else if (payloadType === 'bypassBassed') {
                                                    if (checkPassed(response.data)) {
                                                        vulnerability.GET[url] = {
                                                            paramName,
                                                            payloadValue
                                                        };
                                                        gotVuln++;
                                                        if (gotVuln >= 2) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    console.log('No query parameters found. Skipping GET requests.');
                                }
                    
                                // Do POST
                                if (formDataNames.length > 0 && !gotGet) {
                                    for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                                        if (gotVuln > 5) {
                                            break;
                                        }
                                        for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                                            const formData = new URLSearchParams();
                                            formDataNames.forEach((name) => {
                                                formData.append(name, payloadValue);
                                            });
                                            const requestOptions = {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                                body: formData.toString(),
                                            };
                                            const response = await sendRequest(url, formData.toString(), requestOptions.headers, requestOptions.method);
                                            console.log("Payload:", payloadValue);
                                            if (payloadType === 'bypassBassed') {
                                                if (await checkPassed(response.data)) {
                                                    vulnerability.POST[url] = payloadValue;
                                                    gotVuln++;
                                                    if (gotVuln >= 5) {
                                                        break;
                                                    }
                                                }
                                            } else if (sameFunc.includes(payloadType)) {
                                                if (await checkResponse(response.data)) {
                                                    vulnerability.POST[url] = payloadValue;
                                                    gotVuln++;
                                                    if (gotVuln >= 5) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    console.log('No form data names found. Skipping POST requests.');
                                }
                    
                                if (Object.keys(vulnerability.GET).length === 0 && vulnerability.POST.length === 0) {
                                    console.log("Found nothing, moving to time-based vulnerability check!");
                                    await checkTimeBasedVulnerability(url, queryParams, formDataNames);
                                }
                    
                                console.log('Vulnerability:', vulnerability);
                            } catch (error) {
                                console.error('Error:', error);
                            }
                        }
                        return vulnerability;
                    }
                    for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                        for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                            const testUrl = `${url}?${paramName}=${encodeURIComponent(payloadValue)}`;
                            const response = await sendRequest(testUrl, null, null, 'GET');
                            if (sameFunc.includes(payloadType)) {
                                if (checkResponse(response.data)) {
                                    if (!vulnerability.GET[url]) {
                                        vulnerability.GET[url] = [];
                                    }
                                    vulnerability.GET[url].push({
                                        paramName,
                                        payloadValue
                                    });
                                    gotVuln++;
                                    if (gotVuln >= 2) {
                                        break;
                                    }
                                }
                            } else if (payloadType === 'bypassBassed') {
                                if (checkPassed(response.data)) {
                                    if (!vulnerability.GET[url]) {
                                        vulnerability.GET[url] = [];
                                    }
                                    vulnerability.GET[url].push({
                                        paramName,
                                        payloadValue
                                    });
                                    gotVuln++;
                                    if (gotVuln >= 2) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                console.log('No query parameters found. Skipping GET requests.');
            }

            // Do POST
            if (formDataNames.length > 0 && !gotGet) {
                for (const [payloadType, payloadsOfType] of Object.entries(payloads)) {
                    if (gotVuln > 5) {
                        break;
                    }
                    for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
                        const formData = new URLSearchParams();
                        formDataNames.forEach((name) => {
                            formData.append(name, payloadValue);
                        });
                        const requestOptions = {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: formData.toString(),
                        };
                        const response = await sendRequest(url, formData.toString(), requestOptions.headers, requestOptions.method);
                        console.log("Payload:", payloadValue);
                        if (payloadType === 'bypassBassed') {
                            if (await checkPassed(response.data)) {
                                if (!vulnerability.POST[url]) {
                                    vulnerability.POST[url] = [];
                                }
                                vulnerability.POST[url].push(payloadValue);
                                gotVuln++;
                                if (gotVuln >= 5) {
                                    break;
                                }
                            }
                        } else if (sameFunc.includes(payloadType)) {
                            if (await checkResponse(response.data)) {
                                if (!vulnerability.POST[url]) {
                                    vulnerability.POST[url] = [];
                                }
                                vulnerability.POST[url].push(payloadValue);
                                gotVuln++;
                                if (gotVuln >= 5) {
                                    break;
                                }
                            }
                        }
                    }
                }
            } else {
                console.log('No form data names found. Skipping POST requests.');
            }

            if (Object.keys(vulnerability.GET).length === 0 && Object.keys(vulnerability.POST).length === 0) {
                console.log("Found nothing, moving to time-based vulnerability check!");
                await checkTimeBasedVulnerability(url, queryParams, formDataNames);
            }

            console.log('Vulnerability:', vulnerability);
        } catch (error) {
            console.error('Error:', error);
        }
    }
    return vulnerability;
}


const checkTimeBasedVulnerability = async () => {
    const urls = Object.keys(global.scrapedData);
    for (const url of urls) {
        const payloadsOfType = timePayloads;
        for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
            const { queryParams, formDataNames } = await getData(global.scrapedData[url].htmlContent);
            for (const paramName of queryParams) {
                const testUrl = `${url}?${paramName}=${encodeURIComponent(payloadValue)}`;
                const requestOptions = { sendTime: true };
                const response = await fetchRequest(testUrl, requestOptions);
                if (response.responseTime && response.responseTime >= 5000) {
                    console.log(`Time-Based SQL injection successful for ${payloadValue}`);
                    return;
                }
            }
        }

        for (const [payloadKey, payloadValue] of Object.entries(payloadsOfType)) {
            const formData = new URLSearchParams();
            formDataNames.forEach((name) => {
                formData.append(name, payloadValue);
            });
            const requestOptions = {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: formData.toString(),
                sendTime: true,
                redirect: "follow"
            };
            const response = await fetchRequest(url, requestOptions);
            if (response.responseTime && response.responseTime >= 5000) {
                console.log(`Time-Based SQL injection successful for ${payloadValue}`);
                return;
            }
        }

        console.log('Time-Based SQL injection not detected on', url);
    }
};

module.exports = {
    isItUp,
    checkHeaders,
    outDated,
    pathTraversalCheck,
    checkSQLi,
}