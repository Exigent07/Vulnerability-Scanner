const { curlRequest } = require('../utils/curlUtils');
const { pathTraversal } = require('../utils/vulnerabilitiesUtils/pathTraversalUtils');
const { 
    sqliTest, 
    checkPassed, 
    getData 
} = require('../utils/vulnerabilitiesUtils/sqliUtils');
const getOutDated = require('../utils/techScannerUtils');
const { fetchRequest } = require('../utils/fetchUtils');
const { param } = require('../routes/api');

const isItUp = async (url) => {
    const responseCode = (await curlRequest(url, options)).response;
    console.log('Response Code:', responseCode);
    if (responseCode !== '200' && responseCode !== '302') {
        return false;
    } else {
        return true;
    }
}

const checkHeaders = async (url) => {
    const headersData = (await fetchRequest(url, { getHeaders: true })).headers;

    let missingHeaders = [];
    for (const header of securityHeaders) {
        if (!headersData.hasOwnProperty(header)) {
            missingHeaders.push(header);
        }
    }

    return missingHeaders;
}

const outDated = async (url) => {
    const outDatedComponents = await getOutDated(url);

    return outDatedComponents;
}

const pathTraversalCheck = async (url) => {
    const traversalResult = await pathTraversal(url);
    return traversalResult;
}

const checkSQLi = async (url) => {
    let vulnerability = {};
    let getVulnerability = [];
    let postVulnerability = [];

    try {
        const html = await fetchRequest(url);
        const payloads = (await sqliTest(html))['data'];
        const { queryParams, formDataNames } = await getData(html['data']);

        let requestCounter = 0;
        if (queryParams.length !== 0) {
            for (const query of queryParams) {
                for (const payload of payloads) {
                    const currentUrl = `${url}?${query}=${payload}`;
                    const response = await fetchRequest(currentUrl);
                    const isLoggedIn = await checkPassed(response);
                    if (isLoggedIn === 'Y') {
                        getVulnerability.push({ query: payload });
                    }
                    requestCounter++;
                    if (requestCounter % 15 === 0) {
                        await delay(2000);
                    }
                }
            }
        }

        requestCounter = 0; // Reset counter for POST requests
        if (formDataNames.length !== 0) {
            for (const formName of formDataNames) {
                for (const payload of payloads) {
                    const formData = new FormData();
                    formData.append(formName, payload);
                    const response = await fetchRequest(url, { method: 'POST', body: formData });
                    const isLoggedIn = await checkPassed(response);
                    if (isLoggedIn === 'Y') {
                        postVulnerability.push({ formName: payload });
                    }
                    requestCounter++;
                    if (requestCounter % 15 === 0) {
                        await delay(2000);
                    }
                }
            }
        }

        vulnerability = { getVulnerability, postVulnerability };
    } catch (error) {
        console.error('Error:', error);
    }
    console.log(vulnerability);
    return vulnerability;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

checkSQLi('http://localhost:8080/login');

module.exports = {
    isItUp,
    checkHeaders,
    outDated,
    pathTraversalCheck,
    checkSQLi,
}