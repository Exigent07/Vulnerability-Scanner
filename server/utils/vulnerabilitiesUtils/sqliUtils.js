const prompt = require('../fixUtils');
const cheerio = require('cheerio');
const { encode } = require('html-entities');

// Controller for vulnFix
async function testTimeBased(url, method, payload, requestBody = {}) {
    try {
        const testUrl = method === 'GET' ? `${url}?${payload}` : url;
        const requestOptions = {
            method,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            ...(method === 'POST' && { body: new URLSearchParams(requestBody).toString() }),
        };

        const response = await fetchRequest(testUrl, requestOptions);

        if (response.responseTime && response.responseTime >= 5000) {
            console.log(`Time-Based SQL injection successful for ${payload}`);
            return { data: payload };
        } else {
            console.log(`Time-Based SQL injection not detected on ${url}`);
            return false;
        }
    } catch (error) {
        console.error(`Error occurred: ${error.message}`);
        return false;
    }
}

async function checkPassed(html) {
    const request = `Given the following HTML content:
${encode(html)}

Please respond with Y if this page looks like a user page that he has already logged in and N for not a page that looks like an already logged-in page. Note: The system is now acting as a Web Application Firewall (WAF).`;

    const userResponse = await prompt(request);

    console.log('User response:', userResponse);

    if (userResponse === 'Y') {
        return true;
    } else {
        return false;
    }
}


async function getData(html) {
    const $ = cheerio.load(html);

    const queryParams = [];
    const formDataNames = [];

    $('a').each(function() {
        const href = $(this).attr('href');
        const url = new URL(href, 'http://example.com');
        const searchParams = url.searchParams;
        searchParams.forEach(param => queryParams.push(param));
    });

    $('form').each(function() {
        const form = $(this);
        const formAction = form.attr('action');
        const formMethod = form.attr('method') || 'GET';
        const url = new URL(formAction, 'http://example.com');
        const formParams = form.serializeArray();
        if (formMethod.toUpperCase() === 'GET') {
            formParams.forEach(param => queryParams.push(param.name));
        } else {
            formParams.forEach(param => formDataNames.push(param.name));
        }
    });

    return { queryParams, formDataNames };
}


const checkResponse = async (response) => {
    const keywords = [
        'Logged In',
        'SQLi Found',
        'Welcome',
        'MySQL server error',
        'MySQL syntax error',
        'MySQL query error',
        'mysqli_sql_exception',
        'You have an error in your SQL syntax',
        'right syntax to use near',
        'error in your SQL syntax',
    ];

    for (const keyword of keywords) {
        if (response.includes(keyword)) {
            return true;
        }
    }

    return false;
};

const sendRequest = async (url, requestData, headers, method) => {
    try {
        const response = await fetch('http://127.0.0.1:1338/request', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                url: url,
                method: method,
                data: requestData,
                headers: headers
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('Error:', error.message);
        return null;
    }
};


module.exports = {
    checkPassed,
    getData,
    testTimeBased,
    checkResponse,
    sendRequest,

}